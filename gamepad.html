<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Stack Gamepad - Multiplayer touch controller" />
  <title>Stack Gamepad</title>
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      font-family: 'Arial', sans-serif;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #touchButton {
      position: relative;
      width: 90%;
      max-width: 400px;
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.5rem, 6vw, 3rem);
      font-weight: bold;
      color: #fff;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      background: linear-gradient(145deg, #2c3e50, #34495e);
      border: 3px solid #3498db;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: all 0.2s ease;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #touchButton:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      border-color: #2ecc71;
    }

    #touchButton:active {
      transform: translateY(0);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    #touchButton.connected {
      background: linear-gradient(145deg, #27ae60, #2ecc71);
      border-color: #2ecc71;
      animation: pulse 2s infinite;
    }

    #touchButton.error {
      background: linear-gradient(145deg, #c0392b, #e74c3c);
      border-color: #e74c3c;
    }

    #touchButton.simulation {
      background: linear-gradient(145deg, #f39c12, #e67e22);
      border-color: #f39c12;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 8px 32px rgba(46, 204, 113, 0.3);
      }

      50% {
        box-shadow: 0 8px 32px rgba(46, 204, 113, 0.6);
      }

      100% {
        box-shadow: 0 8px 32px rgba(46, 204, 113, 0.3);
      }
    }

    #statusInfo {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      color: #bdc3c7;
      font-size: 0.9rem;
      text-align: center;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
    }

    #errorMessage {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      color: #e74c3c;
      font-size: 0.8rem;
      text-align: center;
      background: rgba(231, 76, 60, 0.1);
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #e74c3c;
      display: none;
    }

    .loading {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* Responsive design */
    @media (max-width: 480px) {
      #touchButton {
        width: 95%;
        height: 150px;
        font-size: clamp(1.2rem, 5vw, 2rem);
      }

      #statusInfo {
        font-size: 0.8rem;
        top: 10px;
        left: 10px;
        right: 10px;
      }
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <div id="statusInfo">Initializing...</div>
    <div id="touchButton">TAP TO STACK</div>
    <div id="errorMessage"></div>
  </div>

  <script>
    // Enhanced Stack Gamepad with multiple connection modes
    (function () {
      'use strict';

      // Configuration and state
      const config = {
        region: 'eu',
        gameVersion: '1.0',
        maxRetries: 3,
        retryDelay: 2000,
        simulationMode: true, // Enable simulation mode by default
        useWebRTC: false, // Future: WebRTC P2P support
        useWebSocket: false // Future: Custom WebSocket server
      };

      let state = {
        client: null,
        retryCount: 0,
        isConnected: false,
        roomName: null,
        playerId: null,
        appId: null,
        connectionMode: 'simulation' // 'photon', 'websocket', 'webrtc', 'simulation'
      };

      // DOM elements
      const elements = {
        touchButton: document.getElementById('touchButton'),
        statusInfo: document.getElementById('statusInfo'),
        errorMessage: document.getElementById('errorMessage')
      };

      // Utility functions
      const utils = {
        updateStatus: (message, isError = false) => {
          console.log(`[Status] ${message}`);
          elements.statusInfo.textContent = message;
          if (isError) {
            elements.statusInfo.style.color = '#e74c3c';
          } else {
            elements.statusInfo.style.color = '#bdc3c7';
          }
        },

        showError: (message) => {
          console.error(`[Error] ${message}`);
          elements.errorMessage.textContent = message;
          elements.errorMessage.style.display = 'block';
          elements.touchButton.classList.add('error');
          setTimeout(() => {
            elements.errorMessage.style.display = 'none';
            elements.touchButton.classList.remove('error');
          }, 5000);
        },

        updateButtonState: (text, className = '') => {
          elements.touchButton.textContent = text;
          elements.touchButton.className = className;
        },

        parseUrlParams: () => {
          const params = new URLSearchParams(window.location.search);
          return {
            appId: params.get('appId'),
            room: params.get('room'),
            player: parseInt(params.get('player'), 10),
            mode: params.get('mode') || 'simulation' // Allow mode override
          };
        },

        validateParams: (params) => {
          if (!params.room) {
            throw new Error('Missing room parameter');
          }
          if (isNaN(params.player) || params.player < 0 || params.player > 2) {
            throw new Error('Invalid player parameter (must be 0, 1, or 2)');
          }
          return true;
        },

        generateSessionId: () => {
          return 'session_' + Math.random().toString(36).substr(2, 9);
        }
      };

      // Simulation Mode Client - Works without external servers
      class SimulationClient {
        constructor(appId, gameVersion) {
          this.appId = appId;
          this.gameVersion = gameVersion;
          this.state = 'Disconnected';
          this.room = null;
          this.sessionId = utils.generateSessionId();
          this.isSimulation = true;

          // Event callbacks
          this.onStateChange = null;
          this.onError = null;
          this.onJoinRoom = null;
          this.onLeaveRoom = null;
          this.onEvent = null;
        }

        connectToRegionMaster(region) {
          this.setState('Connecting');
          utils.updateStatus('Starting simulation mode...');

          // Simulate connection delay
          setTimeout(() => {
            this.setState('Connected');
            setTimeout(() => {
              this.setState('JoinedLobby');
            }, 500);
          }, 1000);
        }

        joinOrCreateRoom(roomName, roomOptions) {
          console.log('[Simulation] Joining/Creating room:', roomName);
          this.room = {
            name: roomName,
            options: roomOptions || {},
            players: [state.playerId], // Simulate this player in room
            sessionId: this.sessionId
          };

          // Simulate room join
          setTimeout(() => {
            this.setState('Joined');
            if (this.onJoinRoom) {
              this.onJoinRoom();
            }
          }, 800);
        }

        raiseEvent(eventCode, eventData, eventOptions) {
          if (this.state !== 'Joined') {
            console.warn('[Simulation] Cannot raise event: not in room');
            return false;
          }

          console.log(`[Simulation] Event raised - Code: ${eventCode}, Data: ${eventData}`);

          // In simulation mode, we can:
          // 1. Log to console for debugging
          // 2. Store events locally
          // 3. Send to a custom WebSocket server if available
          // 4. Use localStorage to communicate between multiple tabs (same room)

          this.broadcastToLocalTabs(eventCode, eventData, eventOptions);
          return true;
        }

        broadcastToLocalTabs(eventCode, eventData, eventOptions) {
          // Use localStorage events to communicate between tabs in the same room
          const eventMessage = {
            type: 'gamepad_event',
            room: this.room.name,
            eventCode: eventCode,
            eventData: eventData,
            playerId: state.playerId,
            timestamp: Date.now(),
            sessionId: this.sessionId
          };

          try {
            // Store event temporarily
            const storageKey = `gamepad_events_${this.room.name}`;
            const existingEvents = JSON.parse(localStorage.getItem(storageKey) || '[]');

            // Keep only recent events (last 10)
            existingEvents.push(eventMessage);
            if (existingEvents.length > 10) {
              existingEvents.shift();
            }

            localStorage.setItem(storageKey, JSON.stringify(existingEvents));

            // Trigger storage event for other tabs
            localStorage.setItem('gamepad_trigger', Date.now().toString());

            console.log('[Simulation] Event broadcasted via localStorage');
          } catch (error) {
            console.warn('[Simulation] LocalStorage not available, using console only');
          }
        }

        setState(newState) {
          const oldState = this.state;
          this.state = newState;
          console.log(`[Simulation] State: ${oldState} → ${newState}`);

          if (this.onStateChange) {
            this.onStateChange(newState);
          }
        }

        getState() {
          return this.state;
        }

        disconnect() {
          this.setState('Disconnected');
        }
      }

      // WebSocket Client (for custom server)
      class WebSocketClient {
        constructor(appId, gameVersion) {
          this.appId = appId;
          this.gameVersion = gameVersion;
          this.state = 'Disconnected';
          this.websocket = null;
          this.room = null;

          // Event callbacks
          this.onStateChange = null;
          this.onError = null;
          this.onJoinRoom = null;
          this.onLeaveRoom = null;
          this.onEvent = null;
        }

        connectToRegionMaster(region) {
          this.setState('Connecting');

          // Try to connect to a custom WebSocket server
          // You would replace this URL with your actual server
          const wsUrl = 'wss://your-gamepad-server.com/ws';

          try {
            this.websocket = new WebSocket(wsUrl);

            this.websocket.onopen = () => {
              console.log('[WebSocket] Connected to custom server');
              this.setState('Connected');
              this.authenticate();
            };

            this.websocket.onmessage = (event) => {
              this.handleMessage(JSON.parse(event.data));
            };

            this.websocket.onerror = (error) => {
              console.error('[WebSocket] Connection error:', error);
              if (this.onError) {
                this.onError('WebSocketError', 'Failed to connect to custom server');
              }
            };

            this.websocket.onclose = () => {
              console.log('[WebSocket] Disconnected');
              this.setState('Disconnected');
            };

          } catch (error) {
            if (this.onError) {
              this.onError('ConnectionError', error.message);
            }
          }
        }

        authenticate() {
          this.sendMessage({
            type: 'authenticate',
            appId: this.appId,
            gameVersion: this.gameVersion
          });
        }

        joinOrCreateRoom(roomName, roomOptions) {
          this.sendMessage({
            type: 'joinRoom',
            roomName: roomName,
            options: roomOptions,
            playerId: state.playerId
          });
        }

        raiseEvent(eventCode, eventData, eventOptions) {
          return this.sendMessage({
            type: 'raiseEvent',
            eventCode: eventCode,
            eventData: eventData,
            options: eventOptions
          });
        }

        sendMessage(message) {
          if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify(message));
            return true;
          }
          return false;
        }

        handleMessage(message) {
          console.log('[WebSocket] Received:', message);

          switch (message.type) {
            case 'authenticated':
              this.setState('JoinedLobby');
              break;
            case 'roomJoined':
              this.setState('Joined');
              if (this.onJoinRoom) this.onJoinRoom();
              break;
            case 'event':
              if (this.onEvent) {
                this.onEvent(message.eventCode, message.eventData, message.playerId);
              }
              break;
          }
        }

        setState(newState) {
          const oldState = this.state;
          this.state = newState;
          console.log(`[WebSocket] State: ${oldState} → ${newState}`);

          if (this.onStateChange) {
            this.onStateChange(newState);
          }
        }

        getState() {
          return this.state;
        }

        disconnect() {
          if (this.websocket) {
            this.websocket.close();
          }
        }
      }

      // Connection manager
      const connectionManager = {
        createClient: (mode, appId, gameVersion) => {
          switch (mode) {
            case 'websocket':
              return new WebSocketClient(appId, gameVersion);
            case 'simulation':
            default:
              return new SimulationClient(appId, gameVersion);
          }
        },

        init: (mode, appId, gameVersion) => {
          try {
            state.client = connectionManager.createClient(mode, appId, gameVersion);
            state.connectionMode = mode;

            connectionManager.setupEventHandlers();

            const modeText = mode === 'simulation' ? 'Simulation Mode' : 'WebSocket Mode';
            utils.updateStatus(`${modeText} initialized`);
            return true;
          } catch (error) {
            utils.showError(`Failed to initialize client: ${error.message}`);
            return false;
          }
        },

        setupEventHandlers: () => {
          const client = state.client;

          client.onStateChange = (state_code) => {
            console.log(`[${state.connectionMode}] State changed to:`, state_code);

            switch (state_code) {
              case 'JoinedLobby':
                utils.updateStatus('Ready, joining room...');
                connectionManager.joinOrCreateRoom();
                break;

              case 'Joined':
                state.isConnected = true;
                const modePrefix = state.connectionMode === 'simulation' ? 'SIM' : 'LIVE';
                utils.updateStatus(`${modePrefix}: Connected to ${state.roomName}`);
                const className = state.connectionMode === 'simulation' ? 'simulation' : 'connected';
                utils.updateButtonState(`READY TO STACK\nPLAYER ${state.playerId}\n(${modePrefix})`, className);
                break;

              case 'Disconnected':
                state.isConnected = false;
                utils.updateStatus('Disconnected');
                connectionManager.handleDisconnection();
                break;

              case 'Connecting':
                utils.updateStatus('Connecting...');
                break;

              case 'Connected':
                utils.updateStatus('Connected, authenticating...');
                break;
            }
          };

          client.onError = (errorCode, errorMsg) => {
            console.error(`[${state.connectionMode}] Error:`, errorCode, errorMsg);
            utils.showError(`Error: ${errorMsg || errorCode}`);
          };

          client.onJoinRoom = () => {
            console.log(`[${state.connectionMode}] Successfully joined room`);
          };

          client.onEvent = (code, content, playerId) => {
            console.log(`[${state.connectionMode}] Received event:`, { code, content, playerId });
          };
        },

        connect: () => {
          try {
            state.client.connectToRegionMaster(config.region);
          } catch (error) {
            utils.showError(`Connection failed: ${error.message}`);
          }
        },

        joinOrCreateRoom: () => {
          try {
            const roomOptions = {
              maxPlayers: 3,
              isVisible: true,
              isOpen: true
            };

            state.client.joinOrCreateRoom(state.roomName, roomOptions);
          } catch (error) {
            utils.showError(`Failed to join room: ${error.message}`);
          }
        },

        sendTapEvent: () => {
          if (!state.isConnected) {
            console.warn('[Client] Tap ignored: not connected');
            return false;
          }

          try {
            const success = state.client.raiseEvent(
              1, // Event code for button press
              state.playerId, // Player ID as event data
              { receivers: 'All', sendReliable: false }
            );

            if (success) {
              console.log(`[Client] Sent tap event for player ${state.playerId}`);

              // Visual feedback
              elements.touchButton.style.transform = 'scale(0.95)';
              setTimeout(() => {
                elements.touchButton.style.transform = '';
              }, 100);
            }

            return success;
          } catch (error) {
            utils.showError(`Failed to send tap: ${error.message}`);
            return false;
          }
        },

        handleDisconnection: () => {
          if (state.connectionMode === 'simulation') {
            // Simulation mode doesn't really disconnect, try to reconnect immediately
            setTimeout(() => {
              connectionManager.connect();
            }, 1000);
            return;
          }

          if (state.retryCount < config.maxRetries) {
            state.retryCount++;
            utils.updateStatus(`Reconnecting... (${state.retryCount}/${config.maxRetries})`);

            setTimeout(() => {
              connectionManager.connect();
            }, config.retryDelay);
          } else {
            utils.showError('Connection failed. Please refresh the page.');
            utils.updateButtonState('CONNECTION FAILED\nREFRESH PAGE', 'error');
          }
        }
      };

      // Input handling
      const inputManager = {
        init: () => {
          elements.touchButton.addEventListener('touchstart', inputManager.handleTap, { passive: false });
          elements.touchButton.addEventListener('mousedown', inputManager.handleTap);
          elements.touchButton.addEventListener('contextmenu', (e) => e.preventDefault());
        },

        handleTap: (event) => {
          event.preventDefault();
          event.stopPropagation();
          connectionManager.sendTapEvent();
        }
      };

      // Main initialization
      const init = async () => {
        try {
          const params = utils.parseUrlParams();
          utils.validateParams(params);

          // Store configuration
          state.appId = params.appId || 'simulation';
          state.roomName = params.room;
          state.playerId = params.player;

          // Determine connection mode
          let connectionMode = params.mode;
          if (!connectionMode) {
            // Auto-detect best mode
            if (params.appId && params.appId.length > 10) {
              connectionMode = 'websocket'; // Try WebSocket first if appId provided
            } else {
              connectionMode = 'simulation';
            }
          }

          utils.updateStatus('Initializing...');

          await new Promise(resolve => setTimeout(resolve, 100));

          if (!connectionManager.init(connectionMode, state.appId, config.gameVersion)) {
            // Fallback to simulation mode
            console.log('[Init] Falling back to simulation mode');
            connectionManager.init('simulation', state.appId, config.gameVersion);
          }

          inputManager.init();
          connectionManager.connect();

        } catch (error) {
          utils.showError(error.message);
          utils.updateButtonState('INVALID PARAMETERS\nCHECK URL', 'error');
        }
      };

      // Event listeners
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden && !state.isConnected && state.client) {
          connectionManager.connect();
        }
      });

      window.addEventListener('beforeunload', () => {
        if (state.client && state.isConnected) {
          state.client.disconnect();
        }
      });

      // Listen for localStorage events (for simulation mode)
      window.addEventListener('storage', (e) => {
        if (e.key === 'gamepad_trigger' && state.connectionMode === 'simulation') {
          // Another tab sent an event - we could handle it here
          console.log('[Simulation] Cross-tab event detected');
        }
      });

      // Start the application
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

    })();
  </script>
</body>

</html>