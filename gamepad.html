<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Stack Gamepad - Multiplayer touch controller" />
  <title>Stack Gamepad</title>
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      font-family: 'Arial', sans-serif;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    #touchButton {
      position: relative;
      width: 90%;
      max-width: 400px;
      height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(1.5rem, 6vw, 3rem);
      font-weight: bold;
      color: #fff;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      background: linear-gradient(145deg, #2c3e50, #34495e);
      border: 3px solid #3498db;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: all 0.2s ease;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    #touchButton:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      border-color: #2ecc71;
    }

    #touchButton:active {
      transform: translateY(0);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    #touchButton.connected {
      background: linear-gradient(145deg, #27ae60, #2ecc71);
      border-color: #2ecc71;
      animation: pulse 2s infinite;
    }

    #touchButton.error {
      background: linear-gradient(145deg, #c0392b, #e74c3c);
      border-color: #e74c3c;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 8px 32px rgba(46, 204, 113, 0.3);
      }

      50% {
        box-shadow: 0 8px 32px rgba(46, 204, 113, 0.6);
      }

      100% {
        box-shadow: 0 8px 32px rgba(46, 204, 113, 0.3);
      }
    }

    #statusInfo {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      color: #bdc3c7;
      font-size: 0.9rem;
      text-align: center;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
    }

    #errorMessage {
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      color: #e74c3c;
      font-size: 0.8rem;
      text-align: center;
      background: rgba(231, 76, 60, 0.1);
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #e74c3c;
      display: none;
    }

    .loading {
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* Responsive design */
    @media (max-width: 480px) {
      #touchButton {
        width: 95%;
        height: 150px;
        font-size: clamp(1.2rem, 5vw, 2rem);
      }

      #statusInfo {
        font-size: 0.8rem;
        top: 10px;
        left: 10px;
        right: 10px;
      }
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <div id="statusInfo">Initializing...</div>
    <div id="touchButton">TAP TO STACK</div>
    <div id="errorMessage"></div>
  </div>

  <script>
    (function () {
      'use strict';

      // Configuration and state
      const config = {
        maxRetries: 3,
        retryDelay: 2000,
        heartbeatInterval: 30000 // Send keepalive every 30 seconds
      };

      let state = {
        websocket: null,
        retryCount: 0,
        isConnected: false,
        roomName: null,
        playerId: null,
        serverUrl: null,
        heartbeatTimer: null
      };

      // DOM elements
      const elements = {
        touchButton: document.getElementById('touchButton'),
        statusInfo: document.getElementById('statusInfo'),
        errorMessage: document.getElementById('errorMessage')
      };

      // Utility functions
      const utils = {
        updateStatus: (message, isError = false) => {
          console.log(`[Status] ${message}`);
          elements.statusInfo.textContent = message;
          if (isError) {
            elements.statusInfo.style.color = '#e74c3c';
          } else {
            elements.statusInfo.style.color = '#bdc3c7';
          }
        },

        showError: (message) => {
          console.error(`[Error] ${message}`);
          elements.errorMessage.textContent = message;
          elements.errorMessage.style.display = 'block';
          elements.touchButton.classList.add('error');
          setTimeout(() => {
            elements.errorMessage.style.display = 'none';
          }, 5000);
        },

        updateButtonState: (text, className = '') => {
          elements.touchButton.textContent = text;
          elements.touchButton.className = className;
        },

        parseUrlParams: () => {
          const params = new URLSearchParams(window.location.search);
          return {
            server: params.get('server') || params.get('ws'), // Support both 'server' and 'ws' parameters
            room: params.get('room'),
            player: parseInt(params.get('player'), 10)
          };
        },

        validateParams: (params) => {
          if (!params.server) {
            throw new Error('Missing server/ws parameter - provide WebSocket URL');
          }
          if (!params.room) {
            throw new Error('Missing room parameter');
          }
          if (isNaN(params.player) || params.player < 0 || params.player > 3) {
            throw new Error('Invalid player parameter (must be 0-3)');
          }

          // Validate WebSocket URL format
          if (!params.server.startsWith('ws://') && !params.server.startsWith('wss://')) {
            throw new Error('Server URL must start with ws:// or wss://');
          }

          return true;
        }
      };

      // WebSocket connection management
      const connectionManager = {
        connect: () => {
          try {
            utils.updateStatus('Connecting to game server...');

            state.websocket = new WebSocket(state.serverUrl);

            state.websocket.onopen = () => {
              console.log('[WebSocket] Connected to server');
              utils.updateStatus('Connected! Joining room...');

              // Send join room message
              connectionManager.joinRoom();

              // Start heartbeat
              connectionManager.startHeartbeat();
            };

            state.websocket.onmessage = (event) => {
              connectionManager.handleMessage(event.data);
            };

            state.websocket.onerror = (error) => {
              console.error('[WebSocket] Connection error:', error);
              utils.showError('Connection failed - check server URL');
            };

            state.websocket.onclose = (event) => {
              console.log('[WebSocket] Connection closed:', event.code, event.reason);
              state.isConnected = false;
              connectionManager.stopHeartbeat();

              if (event.code !== 1000) { // Not a normal closure
                connectionManager.handleDisconnection();
              }
            };

          } catch (error) {
            console.error('[WebSocket] Failed to create connection:', error);
            utils.showError(`Connection failed: ${error.message}`);
          }
        },

        joinRoom: () => {
          const joinMessage = {
            type: 'join',
            room: state.roomName,
            player: state.playerId,
            timestamp: Date.now()
          };

          connectionManager.sendMessage(joinMessage);
          console.log('[WebSocket] Sent join room message');
        },

        sendMessage: (message) => {
          if (!state.websocket || state.websocket.readyState !== WebSocket.OPEN) {
            console.warn('[WebSocket] Cannot send message: connection not ready');
            return false;
          }

          try {
            const messageStr = JSON.stringify(message);
            state.websocket.send(messageStr);
            return true;
          } catch (error) {
            console.error('[WebSocket] Failed to send message:', error);
            return false;
          }
        },

        handleMessage: (data) => {
          try {
            const message = JSON.parse(data);
            console.log('[WebSocket] Received message:', message);

            switch (message.type) {
              case 'joined':
                state.isConnected = true;
                utils.updateStatus(`Connected to room: ${state.roomName}`);
                utils.updateButtonState(`READY TO STACK\nPLAYER ${state.playerId}`, 'connected');
                state.retryCount = 0; // Reset retry count on successful connection
                break;

              case 'error':
                utils.showError(`Server error: ${message.message || 'Unknown error'}`);
                break;

              case 'roomFull':
                utils.showError('Room is full - cannot join');
                break;

              case 'pong':
                console.log('[WebSocket] Received pong - connection alive');
                break;

              default:
                console.log('[WebSocket] Unknown message type:', message.type);
            }
          } catch (error) {
            console.error('[WebSocket] Failed to parse message:', data, error);
          }
        },

        sendTapEvent: () => {
          if (!state.isConnected) {
            console.warn('[WebSocket] Tap ignored: not connected to room');
            return false;
          }

          const tapMessage = {
            type: 'tap',
            player: state.playerId,
            room: state.roomName,
            timestamp: Date.now()
          };

          const success = connectionManager.sendMessage(tapMessage);

          if (success) {
            console.log(`[WebSocket] Sent tap event for player ${state.playerId}`);

            // Visual feedback
            elements.touchButton.style.transform = 'scale(0.95)';
            setTimeout(() => {
              elements.touchButton.style.transform = '';
            }, 100);
          }

          return success;
        },

        startHeartbeat: () => {
          connectionManager.stopHeartbeat(); // Clear any existing timer

          state.heartbeatTimer = setInterval(() => {
            if (state.websocket && state.websocket.readyState === WebSocket.OPEN) {
              connectionManager.sendMessage({ type: 'ping', timestamp: Date.now() });
            }
          }, config.heartbeatInterval);
        },

        stopHeartbeat: () => {
          if (state.heartbeatTimer) {
            clearInterval(state.heartbeatTimer);
            state.heartbeatTimer = null;
          }
        },

        handleDisconnection: () => {
          utils.updateButtonState('TAP TO STACK', '');

          if (state.retryCount < config.maxRetries) {
            state.retryCount++;
            utils.updateStatus(`Connection lost. Retrying... (${state.retryCount}/${config.maxRetries})`);

            setTimeout(() => {
              connectionManager.connect();
            }, config.retryDelay);
          } else {
            utils.showError('Maximum retry attempts reached. Please refresh the page.');
            utils.updateButtonState('CONNECTION FAILED\nREFRESH PAGE', 'error');
          }
        },

        disconnect: () => {
          connectionManager.stopHeartbeat();

          if (state.websocket) {
            state.websocket.close(1000, 'Client disconnecting');
            state.websocket = null;
          }

          state.isConnected = false;
        }
      };

      // Input handling
      const inputManager = {
        init: () => {
          // Add event listeners for both touch and mouse
          elements.touchButton.addEventListener('touchstart', inputManager.handleTap, { passive: false });
          elements.touchButton.addEventListener('mousedown', inputManager.handleTap);

          // Prevent context menu on long press
          elements.touchButton.addEventListener('contextmenu', (e) => e.preventDefault());
        },

        handleTap: (event) => {
          event.preventDefault();
          event.stopPropagation();

          connectionManager.sendTapEvent();
        }
      };

      // Main initialization
      const init = async () => {
        try {
          // Parse and validate URL parameters
          const params = utils.parseUrlParams();
          utils.validateParams(params);

          // Store configuration
          state.serverUrl = params.server;
          state.roomName = params.room;
          state.playerId = params.player;

          utils.updateStatus('Validating parameters...');

          // Wait a bit for DOM to be fully ready
          await new Promise(resolve => setTimeout(resolve, 100));

          // Initialize input handling
          inputManager.init();

          // Start connection
          connectionManager.connect();

        } catch (error) {
          utils.showError(error.message);
          utils.updateButtonState('INVALID PARAMETERS\nCHECK URL', 'error');
        }
      };

      // Handle page visibility changes
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          console.log('[App] Page hidden');
        } else {
          console.log('[App] Page visible');
          // Reconnect if disconnected
          if (!state.isConnected && state.serverUrl && !state.websocket) {
            connectionManager.connect();
          }
        }
      });

      // Handle page unload
      window.addEventListener('beforeunload', () => {
        connectionManager.disconnect();
      });

      // Start the application
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

    })();
  </script>
</body>

</html>